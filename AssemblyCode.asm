ORG 0
ACALL CONFIGURE_LCD
CLR A
MOV DPTR,#FIRST
MOV A,#30H			;PUSH ASCII ZERO TO STACK NOT TO GET ANY ERROR LATER
PUSH A				;IF THE VALUE GIVEN 1 DIGIT THEN POP THE ASCII ZEROS FROM THE STACK
MOV A,#30H			;SAME PROCESS IS DONE HERE
PUSH A
CLR A
MOV R6,#0H			;R6 IS USED FOR COUNTER

LOOP:
	CLR A
	MOVC A,@A+DPTR		;MOVE THE DPTR ON FIRST STRING TO WRITE 'PHI('
	JZ KEYBOARD_LOOP	;LOOP UNTIL 0 COMES
	ACALL SEND_DATA		;DISPLAY EVERY VALUE ENTERED UNTIL 0
	INC DPTR
	SJMP LOOP

ONE:
	MOV A,#31H		;IF THE NUMBER GIVEN IS ONE IT SEND 1 TO LCD
	ACALL SEND_DATA
	SJMP $

KEYBOARD_LOOP:
	ACALL KEYBOARD
	CJNE A,#'A',SAVE	;IT SEARCH A, IF IT DOES NOT FIND GOES TO SAVE SUBROUTINE
	MOV DPTR,#LAST		;IF IT FIND 'A' THEN DPTR GOES TO #LAST STRING PRINT ')='
	SJMP DATA_DIRECT

SAVE:				;SAVE THE EVERY VALUE ENTERED UNTÝL A ENTERED
	PUSH A 			;R6 HOLDS THE COUNT OF NUMBER ENTERED
	ACALL SEND_DATA		;VALUES ARE PUSHED THE STACKS
	INC R6			;ADD R6 1 EVERYTIME PRIME NUMBER IS FOUND
	SJMP KEYBOARD_LOOP

DATA_DIRECT:
	CLR A			;CLEAR A NEW DPTR WILL BE USED
	MOVC A,@A+DPTR
	JZ CONVERT_HEX		;IF DPTR FIND ZERO IT GOES HEX CONVERTER
	ACALL SEND_DATA
	INC DPTR		;IF IT DOES NOT FIND RETURN TO NEXT VALUE OF DPTR
	CLR A
	SJMP DATA_DIRECT

CONVERT_HEX:			;VALUES ARE SAVED IN THE STACK RESPECTIVELY SO THESE MULTIPLIERS WORK ALWAYS
	POP A			;POPPED THE DIGITS HERE
	ANL A,#0FH
	MOV R1,A
	POP A			;POPPED THE DIGITS HERE
	ANL A,#0FH
	MOV B,#10D		;MULTIPLY WITH 10
	MUL AB
	MOV R2,A
	POP A			;POPPED THE DIGITS HERE
	ANL A,#0FH
	MOV B,#100D		;MULTIPLY WITH 100
	MUL AB
	ADD A,R1
	ADD A,R2
	MOV R5,A
	MOV SP,#07H		;TAKE THE SP #07H HERE NOT TO GET ANY ERROR LATER

CHECK_ONE:
	MOV A,R5
	CJNE A,#01D,COUNTER
	SJMP ONE

COUNTER:
	MOV R7,#54D		;NUMBER OF PRIME NUMBERS IN DECIMAL
	MOV DPTR,#PRIMES
	CLR A
	MOV R4,#00H		;PRIME NUMBER COUNTERS

FIND_PRIMES:
	MOVC A,@A+DPTR		;NOW DPTR ON PRIME NUMBERS
	MOV B,A
	MOV A,R5
	ACALL ISDIVISIBLE	;CHECK THE PRIME IS FULLY DIVIDE THE NUMBER
	JC ADD_PRIME		;IF C IS ZERO ADDED THE DIGIT 
	INC DPTR
	DJNZ R7,FIND_PRIMES	;IF 54 PRIME NUMBER CHECKED IT STOPS
	SJMP NEW

ADD_PRIME:
	INC R4
	PUSH 40h		;IT PUSHES THE DIGIT TO 40H
	CLR C			;CLEAR C IT USES IT AGAIN

BACK_TO_FIND:
	INC DPTR
	DJNZ R7,FIND_PRIMES	;LOOP COUNTS TO 54 AGAIN

NEW:
	MOV R0,#20H
	MOV R1,#30H
	MOV 41H,R4		;41H HOLDS THE DIGIT COUNTS
	SJMP SUB

SUB:
	CLR A
	POP A
	MOV @R0,A		;SAVE THE P VALUES FROM STARTING 20H 
	INC R0
	DEC A
	MOV @R1,A		;SAVE THE P-1 VALUES FROM STARTING 30H
	INC R1
	DJNZ R4,SUB 

BCONS1:
	MOV B,#01D		;MOV 1 TO B TO MAKE MULTIPLICATION
	MOV R1,#30H		;GET R1 THE 30H TO ACCESS P-1 VALUES
	MOV R3,41H

NOM:
	MOV A,@R1		;MULTIPLICATE ALL THE P-1 VALUE
	MUL AB
	MOV B,A
	INC R1
	DJNZ R3,NOM
	MOV R2,B		;ALL MULTIPLIED P-1 AT R2
	MOV 3,R4

BCONS2:
	MOV B,#01D		;MOV 1 TO B TO MAKE MULTIPLICATION
	MOV R0,#20H		;GET R0 THE 20H TO ACCESS P VALUES
	MOV R3,41H

DENOM:
	MOV A,@R0		;ALL ULTIPLIED P VALUE
	MUL AB
	MOV B,A
	INC R0
	DJNZ R3,DENOM
	MOV R1,B		;P AT R1

DIVISION:
	MOV A,R5		;AT HERE ALL FORMULA APPLIED AND RESULT IS REGISTERED TO R5
	MOV B,R1
	DIV AB
	MOV B,R2
	MUL AB
	MOV R5,A

DECOMPOSE:
	MOV B,#10D		;HERE NUMBER GETS INTO DIGITS BY DIVIDING 10 EACH TIME
	DIV AB
	MOV R7,B
	MOV B,#10D
	DIV AB
	MOV R6,B
	MOV R5,A		;NOW R7 HOLD LSB AND R5 HOLDS MSB AND R6 HOLDS MIDDLE DIGIT IF THEY EXIST

DIGIT1:
MOV A,R5
ORL A,#30H
ACALL SEND_DATA

DIGIT2:
MOV A,R6
ORL A,#30H
ACALL SEND_DATA

DIGIT3:
MOV A,R7
ORL A,#30H
ACALL SEND_DATA	

SJMP $

CONFIGURE_LCD:
mov a,#38H
acall SEND_COMMAND
mov a,#0FH
acall SEND_COMMAND
mov a,#06H
acall SEND_COMMAND
mov a,#01H
acall SEND_COMMAND
mov a,#80H
acall SEND_COMMAND
ret

SEND_COMMAND:
mov p1,a
clr p3.5
clr p3.6
setb p3.7
acall DELAY
clr p3.7
ret

SEND_DATA:
mov p1,a
setb p3.5
clr p3.6
setb p3.7
acall DELAY
clr p3.7
ret

DELAY:
push 0
push 1
mov r0,#50

DELAY_OUTER_LOOP:
mov r1,#255
djnz r1,$
djnz r0,DELAY_OUTER_LOOP
pop 1
pop 0
ret

KEYBOARD:
	mov	P0, #0ffh
K1:
	mov	P2, #0
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, K1
K2:
	acall	DELAY
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, KB_OVER
	sjmp	K2
KB_OVER:
	acall DELAY
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, KB_OVER1
	sjmp	K2
KB_OVER1:
	mov	P2, #11111110B
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, ROW_0
	mov	P2, #11111101B
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, ROW_1
	mov	P2, #11111011B
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, ROW_2
	mov	P2, #11110111B
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, ROW_3
	ljmp	K2
ROW_0:
	mov	DPTR, #KCODE0
	sjmp	KB_FIND
ROW_1:
	mov	DPTR, #KCODE1
	sjmp	KB_FIND
ROW_2:
	mov	DPTR, #KCODE2
	sjmp	KB_FIND
ROW_3:
	mov	DPTR, #KCODE3
KB_FIND:
	rrc	A
	jnc	KB_MATCH
	inc	DPTR
	sjmp	KB_FIND
KB_MATCH:
	clr	A
	movc	A, @A+DPTR
	ret

;ASCII look-up table 
KCODE0:	DB	'1', '2', '3', 'A'
KCODE1:	DB	'4', '5', '6', 'B'
KCODE2:	DB	'7', '8', '9', 'C'
KCODE3:	DB	'*', '0', '#', 'D'

ISDIVISIBLE:			;THIS IS FIRST SECTÝON SUBROUTINE
	MOV 40H,B
	CLR OV
	CLR C
	DIV AB
	MOV A,B
	MOV B,40H
	CJNE A,#0H,FINAL
	CLR A 
	SETB C
FINAL:
	CLR A
	RET

FIRST: DB 'PHI(',0
LAST: DB ')=',0
PRIMES: DB 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251

END
